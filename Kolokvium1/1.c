#include <stdio.h>

//1. Faktoriel na interval (m,n].
//int main()
//{
//    int m, n;
//    int i;
//    long suma=1;
//    int a;
//    scanf("%d %d",&m,&n);
//    for(i=m+1;i<=n;i++)
//    {
//        for(a=i;a>0;a--)
//        {
//            suma=suma*a;
//        }
//        printf("Faktoriel od %d e %ld\n",i,suma);
//        suma=1;
//    }
//    return 0;
//}

//2. GLUPA ZADAKJA
//int main()
//{
//    int x,n;
//    int x1,x2;
//    int broj;
//    scanf("%d %d",&x, &n)
//    for(int i=0;i<n;i++)
//    {
//        scanf("%d",broj);
//
//
//
//
//        if(i==1 || i==2)
//        continue;
//    }
//    return 0;
//}

//3 NENORMALNA ZADAKJA
//int main()
//{
//    int a,b,c,d,e;
//    int zbir=0;
//    float prosek=0;
//    float brojac=0;
//    scanf("%d %d %d %d %d",&a,&b,&c,&d,&e);
//    for(int i=a;i<=b;i++)
//    {
//        if((i*i)%d==0)
//            zbir+=i;
//        if((i%10==e) || (i/10%10==e))
//        {
//             prosek+=i;
//             brojac++;
//        }
//    }
//    prosek = prosek / brojac;
//    printf("Zbir: %d\n",zbir);
//    printf("Prosek: %.2f\n",prosek);
//
//    return 0;
//}

//1. Од тастатура се внесува цел број n, а потоа и n тројки природни броеви
//(должини на три отсечки). За секоја тројка должини треба да се испечати
//порака Moze ако со нив може да се конструира триаголник, во спротивно се
//печати Ne moze. На крај да се испечати редниот број на тројката броеви со која
//се конструира триаголникот со најголем периметар (се земаат предвид само
//тројките со кои може да се конструира триаголник), како и вредноста на
//најголемиот периметар. Ако постојат повеќе такви тројки броеви, да се
//испечати редниот број на последната. Се смета дека првата внесена тројка е со
//реден број еден, втората со реден број два итн.
//int main()
//{
//    int n;
//    int a,b,c;
//    int perimetar=0;
//    int MaxP;
//    int RB;
//    printf("Vnesi broj na trojki: ");
//    scanf("%d\n",&n);
//    for (int i=1;i<=n;i++)
//    {
//        scanf("%d %d %d",&a,&b,&c);
//        if (a+b>c && a+c>b && b+c>a)
//        {
//            printf("Moze\n");
//            perimetar=a+b+c;
//            if(perimetar>MaxP)
//            {
//                MaxP=perimetar;
//                RB=i;
//            }
//        }
//        else
//        {
//            printf("Ne moze\n");
//        }
//    }
//    printf("Vrednosta na najgolemiot perimetar: %d\n",MaxP);
//    printf("Reden broj: %d\n",RB);
//    return 0;
//}

//2. Да се напише програма во која од тастатура се внесуваат непознат број мали
//букви сѐ додека не се внесе знак што не е мала буква. За секој пар
//последователни букви, во нов ред треба да се испечати секвенца од буквите во
//абецеден редослед што се наоѓаат меѓу нив (без нив) проследено со вкупниот
//број на вакви букви. Секогаш печатењето се почнува од буквата што се наоѓа
//понапред во азбуката кон таа што е поназад. Ако парот букви е составен од две
//соседни букви во азбуката, не се печати ништо. На крај да се испечати
//вкупниот број на испечатени секвенци од букви.
//int main()
//{
//    char x;
//    scanf("%c",&x);
//        if(x>='a'&& x<='z')
//        {
//
//        }
//    return 0;
//}
//OD DAVID RESHENA
//int main()
//{
//    char c;
//    char c1;
//    scanf("%c", &c1);
//    while(scanf("%c", &c) && c <= 'z' && c >= 'a')
//    {
//        char r = c;
//        if(c < c1)
//        {
//            c++;
//            int i = 0;
//            for(i = 0 ; c < c1; c++, i++)
//            {
//                printf("%c", c);
//            }
//            printf(" %d\n", i);
//        }
//        else
//        {
//            c1++;
//            int i = 0;
//            for(i = 0 ; c1 < c; c1++, i++)
//            {
//                printf("%c", c1);
//            }
//            printf(" %d\n", i);
//        }
//        c1 = r;
//    }
//    return 0;
//}

//3.Empires & Allies е стратегиска игра во повеќе нивоа со можност за играње од
//страна на повеќе играчи. Секој играч има своја територија, како и одбранбени
//и напаѓачки единици. Може да влезе во битка (напад на туѓа територија или
//одбрана на сопствената) со други играчи што може да заврши со победа или
//пораз за што се добиваат поени. Да се напише програма во која од тастарура се
//внесува бројот на играчи на играта Empires & Allies. За секој играч потоа се
//внесуваат податоци за ниво (цел број), број на победи и број на порази.
//Резултатот на играчот се пресметува на следниот начин:
//• ако се работи за прво ниво, секоја победа носи 13 поени, а секој пораз носи -1 поен
//• ако се работи за второ ниво, секоја победа носи 13 поени, а секој пораз носи -3 поени
//За секој играч треба да се испечати Dobar igrac ако неговиот број на поени е
//позитивен или Los igrac во сите други случаи. Потоа треба да се најде и
//испечати најдобриот резултат (најголемиот вкупен број на поени), како и
//редниот број на играчот со најдобар резултат (првиот играч е со реден број
//еден, вториот со реден број два итн.). Ако постојат повеќе играчи со ист
//најдобар резултат, да се испечати редниот број на првиот таков играч.
//int main()
//{
//    int n;
//    int nivo,w,l;
//    int poeni=0;
//    int maxp;
//    int RB;
//    printf("Vnesi broj na igraci: ");
//    scanf("%d",&n);
//    for(int i=0;i<n;i++)
//    {
//        scanf("%d %d %d",&nivo,&w,&l);
//        if (nivo==1)
//        {
//            poeni = (w*13) - l;
//        }
//        if (nivo==2)
//        {
//            poeni = (w*13) - (l*3);
//        }
//        if (poeni>0)
//            printf("Dobar igrac\n");
//        else
//            printf("Losh igrac\n");
//
//        if (poeni>maxp)
//            maxp=poeni;
//            RB=i;
//    }
//    printf("Najdobar igrac: br.%d, %d poeni",RB,maxp);
//
//    return 0;
//}

//4. Од тастатура се внесува цел број m, а потоа непознат број цели броеви. Да се
//испечатат должините на секвенците составени од најмалку два
//последователни броја за кои истовремено важи:
//• следниот број е строго поголем од претходниот и
//• секој од нив има точно m цифри.
//Задачата да се реши без користење на низи.
//int main()
//{
//    int m, broj, sekvenca=0;
//    int pc;
//    scanf("%d",&m);
//    for(int i=0;i<m;i++)
//    {
//        scanf("%d",&broj);
//        while(broj>0)
//        {
//        pc=broj%10;
//        int temp=broj/10%10;
//        if(pc<temp)
//        {
//            break;
//        }
//        else
//        broj/10;
//        }
//    }
//    return 0;
//}
//RESENO OD NEKOJ SHUPAK TAMU
//int main () {
//  int c, prev;
//  int first = 1, tmp, noDigits, prevNoDigits;
//  int n = 1, m;
//  scanf("%d", &m);
//  while (scanf ("%d", &c)) {
//  tmp = c;
//  noDigits = 0;
//  while (tmp) {
//  noDigits++;
//  tmp /= 10;
//  }
//  if (first) {
//  first = 0;
//  } else {
//  if (c > prev && noDigits == m && prevNoDigits == m) {
//  n++;
//  } else {
//  if (n >= 2 ) {
//  printf("%d ", n);
//  }
//  n = 1;
//  }
//  }
//  prev = c;
//  prevNoDigits = noDigits;
//  }
//  if (n >= 2 ) {
//  printf("%d", n);
//  }
//  return 0;
//}

//5. Од стандарден влез се чита еден број кој претставува датум во формат DDMMYYYY
//(DD-ден, MM-месец, YYYY-година) кој го означува денешниот датум. Потоа се
//вчитува цел број N, по кој се вчитуваат N датуми на раѓање во дадениот
//формат. За секој од прочитаните N датуми на раѓање треба да се отпечати "DA"
//ако на денешниот ден (вчитан на почетокот) има повеќе или точно 18 години,
//а во спортивно "NE".
//int main()
//{
//    int x;
//    printf("Vnesi datum: ");
//    scanf("%d",&x);
//    int den = x/1000000;
//    int mesec = x/10000%100;
//    int god = x%10000;
//    printf("Go vnese datumot: %d %d %d\n",den,mesec,god);
//    int n;
//    printf("Vnesi broj na datumi: ");
//    scanf("%d",&n);
//    int y;
//    for (int i=0;i<n;i++)
//    {
//        scanf("%d",&y);
//        int den2 = y/1000000;
//        int mesec2 = y/10000%100;
//        int god2 = y%10000;
//        printf("Go vnese datumot: %d %d %d\n",den2,mesec2,god2);
//
//        if((god-god2)>18)
//        {
//            printf("DA\n");
//        }
//        else if((god-god2)==18)
//        {
//            if(mesec2<mesec)
//            {
//                printf("DA\n");
//            }
//            else if(mesec2==mesec)
//            {
//                if(den2<den)
//                {
//                    printf("DA\n");
//                }
//                else
//                    printf("NE\n");
//            }
//            else
//                printf("NE\n");
//        }
//        else if((god-god2)<18)
//            printf("NE\n");
//    }
//    return 0;
//}

//6. Со помош на знаците +,*, и % се формира квадратна слика со „должина“ m
//(m>2) која претставува квадрат од знаците %, впишан во квадрат од
//знаците + и (види примери). За внесено m да се испечати на екран
//соодветната слика. Внимавајте – не печатете нити еден дополнителен знак,
//како празно место, непотребен знак за нов ред… Сликата завршува со знак за
//нов ред.
//+***+
//+%%%+
//+%%%+
//+%%%+
//+***+
//int main()
//{
//    int m;
//    scanf("%d",&m);
//    for(int i=0;i<m;i++)
//    {
//        for(int j=0;j<m;j++)
//        {
//            if((j==0)&&(i>=0)&&(i<=m))
//            {
//                printf("+");
//            }
//            else if((j==m-1)&&(i>=0)&&(i<=m))
//            {
//                printf("+");
//            }
//            else if((i==0)&&(j>=0)&&(j<=m))
//            {
//                printf("*");
//            }
//            else if((i==m-1)&&(j>=0)&&(j<=m))
//            {
//                printf("*");
//            }
//            else
//                printf("%%");
//        }
//        printf("\n");
//    }
//    return 0;
//}

//1.Благ број е број што е составен само од парни цифри (0, 2, 4, 6, 8).
//Во зададен опсег (почетокот m и крајот на опегот n се цели броеви чија вредност се внесува од тастатура),
//да се најде и испечати најмалиот „благ број“. Ако не постои таков број, да се испечати NE.
//int main()
//{
//    int n, m, broj, min, i;
//    scanf("%d %d",&n,&m);
//    if(n%2!=0)
//    {
//        n++;
//    }
//    for(broj=n;broj<=m;broj++)
//    {
//        min=broj;
//        i=0;
//        while(min>0)
//        {
//            min/=10;
//            if(min%2!=0)
//            {
//                i++;
//            }
//        }
//        if(i==0)
//        {
//            printf("%d",broj);
//            break;
//        }
//    }
//    if(i>0)
//        {
//            printf("NE");
//        }
//    return 0;
//}

//2. Eден природен e „интересен“ ако неговиот обратен број е делив со неговиот број на цифри.
//Обратен број е бројот составен од истите цифри, но во обратен редослед (на пример, 653 е
//обратен број на бројот 356). Од тастатура се внесува природен број n ( n > 9). Да се најде и
//отпечати најголемиот природен број помал од n кој што е „интересен“. Ако внесениот број не е валиден,
//да се отпечати соодветна порака (Brojot ne e validen).
//int main()
//{
//    int x, y; //y=obraten
//    int ostatok;
//    scanf("%d",&x);
//    if(x>9)
//    {
//    for(int i=x-1;i>0;i--)
//    {
//        int cifri=0;
//        int temp;
//
//        temp=i;
//        while(temp)
//        {
//            cifri++;
//            temp/=10;
//        }
//        printf("%d\n",cifri);
//
//        temp=i;
//        y=0;
//        while(temp)
//        {
//            ostatok=temp%10;
//            y=y*10+ostatok;
//            temp/=10;
//        }
//        printf("%d\n",y);
//        if(y%cifri==0)
//        {
//            printf("%d",i);
//            break;
//        }
//        else
//        {
//            continue;
//        }
//    }
//    }
//    else
//        printf("Brojot ne e validen");
//
//    return 0;
//}

//3.Од стандарден влез се чита еден природен број n. Меѓу природните броеви помали од n,
//да се најде оној чиј што збир на делителите е најголем. Во пресметувањето на збирот на
//делителите на даден број, да не се зема предвид самиот број.
//int main()
//{
//    int n, zbir=0;
//    int rb;
//    scanf("%d",&n);
//    for (int i=0;i<n-1;i++)
//    {
//        int delitel=1;
//        while(delitel<=i)
//        {
//            if(i%delitel==0)
//            {
//                zbir+=delitel;
//            }
//            delitel++;
//            rb=i;
//        }
//    }
//    printf("%d",rb);
//    return 0;
//}

//4.Од стандарден влез се читаат знаци се додека не се прочита извичник.
//Во вака внесениот текст се скриени цели броеви (помали од 100). Да се напише
//програма што ќе ги прочита сите знаци и на излез ќе го испечати збирот на сите броеви скриени во текстот.
//int main()
//{
//    char x;
//    int a, suma=0;
//    int f=1;
//    while(1)
//    {
//        scanf("%c", &x);
//        if(f==1 && x>='0' && x<='9')
//        {
//            a=(x-'0');
//            f=0;
//        }
//        else if(f==0 && x>='0' && x<='9')
//        {
//            a=(a*10)+(x-'0');
//            suma+=a;
//            f=1;
//        }
//        else if(f==0 && !(x>='0' && x<='9'))
//        {
//            suma+=a;
//            f=1;
//        }
//        if(x=='!')
//            break;
//    }
//    printf("%d",suma);
//    return 0;
//}

//5. Од тастатура се читаат 2 позитивни цели броеви. Доколку се внесе барем еден
//негативен број или 0 треба да се печати „Invalid input“.
//Треба да се определи дали помалиот број “е парен еквивалент” од поголемиот број.
//Еден број “е парен еквивалент” на друг број, ако и само ако неговите цифри се наоѓаат на
//парните позиции од другиот број, во истиот редослед.
//Соодветно да се испечатат пораки „PAREN“ и „NE“.
//Позициите треба да се сметаат оддесно-налево (најмалку значајната цифра е на позиција 1)
//int main()
//{
//    int x, y;
//    scanf("%d %d",&x,&y);
//
//    if(x<1 || y<1)
//    {
//        printf("Invalid input");
//        return 0;
//    }
//    if(y>x)
//    {
//        int temp=y;
//        y=x;
//        x=temp;
//    }
//    //x>y
//    while(x>0&&y>0)
//        {
//        if((x%100)/10 != y%10)
//        {
//            printf("NE\n");
//            return 0;
//        }
//        x=x/100;
//        y=y/10;
//        }
//    printf("PAREN");
//
//    return 0;
//}

//6.Да се напише програма во која од стандарден влез прво се внесува еден позитивен цел број z,
//а потоа последователно се внесуваат парови цели броеви (a, b). Внесувањето на парови цели броеви
//треба да заврши кога корисникот ќе го внесе парот (0, 0). Треба да се пресмета колку пати z е
//еднаков на збирот на секој внесен пар броеви a и b, како и колкав процент од вкупниот број внесени
//парови (a, b) даваат збир z (ЗАБЕЛЕШКА: парот (0, 0) не се зема во предвид при извршувањето на пресметките!).
//int main()
//{
//    int z;
//    int a,b;
//    float zbir=0;
//    float procent=1,i=0;
//    scanf("%d",&z);
//    while(scanf("%d %d",&a,&b))
//    {
//        if(a==0 && b==0)
//            break;
//        i++;
//        if(a+b==z)
//        {
//            zbir++;
//        }
//    }
//    procent = (zbir/i)*100;
//    printf("Vnesovte %.0f parovi od broevi chij zbir e %d\n",zbir,z);
//    printf("Procentot na parovi so zbir %d e %.2f%%",z,procent);
//    return 0;
//}

//7. Со помош на знаците ‘@’,'%', и ‘.‘ се формира квадратна слика со „должина“ m (m>2)
//која претставува квадрат од знаците '.', впишан во квадрат од знаците @ и %(види примери).
//За внесено m да се испечати на екран соодветната слика. Внимавајте – не печатете нити еден
//дополнителен знак, како празно место, непотребен знак за нов ред...
//Сликата завршува со знак за нов ред. Забелешка: Бидејќи е дадено ограничување за m, во
//точно решение на задачата не треба да се користи низа/матрица.
//int main()
//{
//    int m;
//    scanf("%d",&m);
//    for(int i=0;i<m;i++)
//    {
//        for(int j=0;j<m;j++)
//        {
//            if((j==0)&&(i>=0)&&(i<=m-1))
//            {
//                printf("%%");
//            }
//            else if((j==m-1)&&(i>=0)&&(i<=m-1))
//            {
//                printf("%%");
//            }
//            else if((i==0)&&(j>=0)&&(j<m-1))
//            {
//                printf("@");
//            }
//            else if((i==m-1)&&(j>=0)&&(j<m-1))
//            {
//                printf("@");
//            }
//            else
//            {
//                printf(".");
//            }
//        }
//        printf("\n");
//    }
//    return 0;
//}

//8. Од стандарден влез се внесуваат два цели броја N и Х.
//Да се најде најблискот број помал од N коj е тотално различен од бројот Х.
//Еден број е тотално различен од друг ако и само ако во него не се појавува ниту една од цифрите на другиот број.
//Задачата да се реши без употреба на низи и матрици.
//int main()
//{
//    int n,x;
//    scanf("%d %d",&n,&x);
//    for(int i=n-1;n>i;i--)
//    {
//        printf("%d\n",i);
//
//    }
//
//
//    return 0;
//}

//9. Од стандарден влез се читаат непознат број на хексадецимални цифри се додека не се внесе точка (.).
//Ваша задача е да го пресметате декадниот збир на внесените хексадецимални цифри. Доколку добиениот
//декаден збир е делив со 16 се печати Pogodok. Доколку истиот тој збир покрај што е делив со 16 плус
//завршува на 16 (последните цифри му се 1 и 6), се печати Poln pogodok инаку се печати самиот збир.
//Пример:
//влез: A 7 F 2 0 c A 5
//излез: 61
//(61 = 10 + 7 + 15 + 2 + 0 + 12 + 10 + 5, бројот не е делив со 16, ниту пак последните цифри му се 1,6)
//int main()
//{
//    long int x;
//    while(scanf("%d",&x))
//    {
//       if(x=='.')
//            break;
//        else
//        {
//
//
//
//        }
//    }
//
//
//    return 0;
//}

//13. Од тастатура се внесува број на студенти кои ќе полагаат колоквиум, а потоа и индексите
//(цели броеви) на сите студенти кои ќе полагаат колоквиум. Програмата треба да ги подели студентите
//во три групи: студенти со индекси кои завршуваат на цифрата 0, 1 и 2, студенти со индекси кои завршуваат
//на цифрата 3, 4, 5 и студенти со индекси кои завршуваат на цифрата 6, 7, 8, 9. Програмата треба да
//ги испечати индексите за секоја група, во истиот редослед како што биле внесени. Максималниот број
//на студенти што може да се внесат е 1000.
//Влез:
//10 //Kolku studenti?
//20010 20145 20147 20139 20581 19452 19873 19825 19458 20653 //Koi studenti?
//Излез
//Grupa 1
//20010 20581 19452
//Grupa 2
//20145 19873 19825 20653
//Grupa 3
//20147 20139 19458
//int main()
//{
//    int bs;
//    int indeks;
//    int a=0,b=0,c=0;
//    int gr1[a],gr2[b],gr3[c];
//    scanf("%d",&bs);
//    for(int i=bs;i>0;i--)
//    {
//
//        scanf("%d\n",&indeks);
//        if(indeks%10==0||indeks%10==1||indeks%10==2)
//        {
//            gr1[a]=indeks;
//            a++;
//        }
//        if(indeks%10==3||indeks%10==4||indeks%10==5)
//        {
//            gr3[b]=indeks;
//            b++;
//        }
//        if(indeks%10==6||indeks%10==7||indeks%10==8||indeks%10==9)
//        {
//            gr3[c]=indeks;
//            c++;
//        }
//    }
//    printf("%d\n %d\n %d\n",gr1[a],gr2[b],gr3[c]);
//
//    return 0;
//}
